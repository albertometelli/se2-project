#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass article
\begin_preamble
 \usepackage{algorithm}
 \usepackage{algorithmicx}
\usepackage{algpseudocode}
\usepackage{tikz}
\usetikzlibrary{positioning}
\usetikzlibrary{arrows}
\usepackage{pdflscape}
\end_preamble
\use_default_options true
\master ../DD.lyx
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_math auto
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\float_placement H
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
In this section we will show some of the most significant algorithms that
 should be implemented in the following phases of project.
 We prefer to remain abstract with respect to a specific programming language
 therefore the algorithms will be typically expressed in pseudocode.
 Notice that the following algorithms do not represent an implementation
 constraint but just a suggestion for the developer about the way in this
 phase the algorithms have been designed.
\end_layout

\begin_layout Subsection
Taxi queue manager
\end_layout

\begin_layout Standard
Taxi queue manager is in charge of ensuring the 
\begin_inset Quotes eld
\end_inset

fair distribution
\begin_inset Quotes erd
\end_inset

 of taxis among the zones.
 The main functionalists can be depicted in the following private methods:
\end_layout

\begin_layout Itemize

\emph on
computePositions
\emph default
: by means of the GPS information asked to the taxi GPS, installs the current
 distribution of the taxis in the queue of each zone, taxis moved into a
 new zone are added at the end of the queue;
\end_layout

\begin_layout Itemize

\emph on
selectTaxisToMove
\emph default
: using a specific algorithm, that will be explained later, selects the
 number of taxis that have to be moved for each zone;
\end_layout

\begin_layout Itemize

\emph on
relocateTaxis
\emph default
: the function checks if there are zones lacking of taxis and in case invokes
 selectTaxisToMove in order to get the number of taxis to be moved and selects
 those taxis among the ones in the queues.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithmic}[1]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
Function{computePosition()}{}
\end_layout

\begin_layout Plain Layout

	
\backslash
State $taxis 
\backslash
gets TaxiQueueManager.getAvailableTaxis()$
\end_layout

\begin_layout Plain Layout

	
\backslash
ForAll{$t 
\backslash
in taxis$}
\end_layout

\begin_layout Plain Layout

		
\backslash
State $location 
\backslash
gets TaxiPositionFinder.getTaxiPosition(t)$
\end_layout

\begin_layout Plain Layout

		
\backslash
State $newZone 
\backslash
gets location.getZone()$
\end_layout

\begin_layout Plain Layout

		
\backslash
State $oldZone 
\backslash
gets t.getLocation().getZone()$
\end_layout

\begin_layout Plain Layout

		
\backslash
If{$zone 
\backslash
neq oldZone$}
\end_layout

\begin_layout Plain Layout

			
\backslash
State $TaxiQueueManager.move(t, oldZone, newZone)$
\end_layout

\begin_layout Plain Layout

		
\backslash
EndIf
\end_layout

\begin_layout Plain Layout

	
\backslash
EndFor
\end_layout

\begin_layout Plain Layout


\backslash
EndFunction
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
computePosition
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Selection of the number of taxis to be moved
\end_layout

\begin_layout Standard
Before formalizing and proposing a solution to the problem of moving taxis
 among zones in order to satisfy the constraint of the minimum number of
 taxis in each zone, minimizing the number of zones traveled, we give some
 useful definitions.
\end_layout

\begin_layout Itemize
\begin_inset Formula $Z$
\end_inset

 the set of zones in which the city is divided.
\end_layout

\begin_layout Itemize
\begin_inset Formula $N$
\end_inset

 total number of available taxis at the moment.
\end_layout

\begin_layout Itemize
\begin_inset Formula $n_{i}$
\end_inset

 number of requests per minute in the zone 
\begin_inset Formula $i$
\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout
We assume this datum to be available from previous analysis; if not it can
 be estimated after a certain time of activity of the system.
 See RASD, section 2.5
\end_layout

\end_inset

.
\end_layout

\begin_layout Itemize
\begin_inset Formula $t_{i}$
\end_inset

 suitable number of available taxis in the zone 
\begin_inset Formula $i$
\end_inset

.
\end_layout

\begin_layout Itemize
\begin_inset Formula $t_{i,min}$
\end_inset

(
\begin_inset Formula $t_{i,max}$
\end_inset

) minimum (maximum) acceptable number of available taxis in the zone 
\begin_inset Formula $i$
\end_inset

.
\end_layout

\begin_layout Itemize
\begin_inset Formula $q_{i}$
\end_inset

 actual number of available taxis in the zone 
\begin_inset Formula $i$
\end_inset

.
\end_layout

\begin_layout Standard
We would like to distribute taxis among zones proportionally to the number
 of requests per minute.
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
t_{i}=\frac{n_{i}}{\sum_{i}n_{i}}N
\]

\end_inset


\end_layout

\begin_layout Standard
and we accept a tolerance of 30% so 
\begin_inset Formula $t_{i,max}=1.3t_{i}$
\end_inset

, 
\begin_inset Formula $t_{i,min}=0.7t_{i}$
\end_inset

.
\end_layout

\begin_layout Standard
Our algorithm should be able to ensure that, after its execution, 
\begin_inset Formula $t_{i,min}\leq q_{i}\leq t_{i,max}$
\end_inset

.
 Note that the most important condition is that 
\begin_inset Formula $q_{i}\geq t_{i,min}$
\end_inset

 to satisfy 
\emph on
demand
\emph default
 of the taxis, the second constraint, that is 
\begin_inset Formula $q_{i}\leq t_{i,max}$
\end_inset

 is useful to ensure the 
\emph on
balancing
\emph default
 of the taxis.
 In the next section we provide a formalization of the problem as a linear
 programming model and in the following an algorithm to solve it.
\end_layout

\begin_layout Subsubsection
Linear formalization of the problem in section 3.1.1
\end_layout

\begin_layout Standard
The zones can be naturally represented as an undirected graph 
\begin_inset Formula $G=\left(Z,A\right)$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
A=\{(i,j)|i,j\in Z,zone\: i\: adjacent\: to\: zone\: j\}
\]

\end_inset


\end_layout

\begin_layout Standard
Note that, since the graph is undirected, the adjacency relation is symmetric
 so if 
\begin_inset Formula $(i,j)\in A$
\end_inset

 also 
\begin_inset Formula $(j,i)\in A$
\end_inset

.
 The graph 
\begin_inset Formula $G$
\end_inset

 is unweighted, since we are interested in minimizing the number of zones
 traveled (and not directly the distance in km!).
 Starting from 
\begin_inset Formula $G$
\end_inset

 we can easily compute its transitive closure
\begin_inset Foot
status open

\begin_layout Plain Layout
Just transitive, not reflexive because we are not interested in paths from
 one node to itself.
\end_layout

\end_inset

 (we assume that 
\begin_inset Formula $G$
\end_inset

 is connected for obvious reasons), registering in the meanwhile the distance
 (in terms of number of zones traveled) between each pair of zones.
 This can be done, for instance, iterating BFS for each source node (with
 a complexity of 
\begin_inset Formula $O(|Z||A|)$
\end_inset

) the output is a weighted graph 
\begin_inset Formula $G^{+}=(Z,A^{+})$
\end_inset

 where the weights are 
\begin_inset Formula $d_{ij}$
\end_inset

, i.e.
 the length of the shortest path (from now on called distance) between node
 
\begin_inset Formula $i$
\end_inset

 and node 
\begin_inset Formula $j$
\end_inset

.
 Let's partition the zones into two categories 
\begin_inset Formula $\{Z_{+},Z_{-}\}$
\end_inset

 where 
\begin_inset Formula $Z_{+}$
\end_inset

 contains the zones s.t.
 
\begin_inset Formula $q_{i}\geq t_{i,min}$
\end_inset

 and 
\begin_inset Formula $Z_{-}$
\end_inset

 contains all zones s.t.
 
\begin_inset Formula $q_{i}<t_{i,min}$
\end_inset

, so 
\begin_inset Formula $Z_{-}$
\end_inset

 contains the zones lacking of taxis.
 Notice that we are only interested in the arcs of 
\begin_inset Formula $G$
\end_inset

 like 
\begin_inset Formula $(i,j)$
\end_inset

 where 
\begin_inset Formula $i\in Z_{+}$
\end_inset

 and 
\begin_inset Formula $j\in Z_{-}$
\end_inset

 because taxis have to be moved from a zone having more than needed taxis
 to a zone in which some taxis are needed, so we assume to erase the others
 and we obtain a bi-partied directed graph.
\end_layout

\begin_layout Standard
Let's call 
\begin_inset Formula $x_{ij}$
\end_inset

 the number of taxis moved from zone 
\begin_inset Formula $i\in Z_{+}$
\end_inset

 to zone 
\begin_inset Formula $j\in Z_{-}$
\end_inset

 (decision variable).
 Referring to the previous notation, we can easily define the objective
 function:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\min\sum_{i\in Z_{+}}\sum_{j\in Z_{-}}d_{ij}x_{ij}
\]

\end_inset


\end_layout

\begin_layout Standard
subject to the following constraints:
\end_layout

\begin_layout Itemize
\begin_inset Formula $x_{ij}\geq0\:\forall i\in Z_{+},j\in Z_{-}$
\end_inset

 (non negativity constraint);
\end_layout

\begin_layout Itemize
\begin_inset Formula $q_{i}-\sum_{j\in Z_{-}}x_{ij}\geq t_{i,min}\:\forall i\in Z_{+}$
\end_inset

 (availability constraint);
\end_layout

\begin_layout Itemize
\begin_inset Formula $q_{j}+\sum_{i\in Z_{+}}x_{ij}\geq t_{j,min}\:\forall j\in Z_{-}$
\end_inset

 (demand constraint);
\end_layout

\begin_layout Itemize
\begin_inset Formula $x_{ij}$
\end_inset

 integer 
\begin_inset Formula $\forall i\in Z_{+}$
\end_inset

, 
\begin_inset Formula $\forall j\in Z_{-}$
\end_inset

.
\end_layout

\begin_layout Standard
It's not difficult to recognize in that formulation a 
\emph on
minimum cost flow 
\emph default
problem
\begin_inset Foot
status open

\begin_layout Plain Layout
The minimum cost flow problem consists in determining the flow on the arcs
 of the network so that all available flow leaves from sources, all required
 flow arrives at origins, arc capacities are not exceeded and the global
 cost of the flow on arcs is minimized.
 
\end_layout

\end_inset

 in a network 
\begin_inset Formula $G'=(Z\cup\{s,t\},A')$
\end_inset

 where 
\begin_inset Formula $A'=\{(i,j)\in A^{+}|i\in Z_{+}j\in Z_{-}\}\cup\{(s,i)|i\in Z_{+}\}\cup\{(j,t)|j\in Z_{-}\}$
\end_inset

.
 Notice that we have added a source and a sink suitably connected to the
 other nodes.
 The costs are given by the distances and we assume that 
\begin_inset Formula $d_{si}=d_{jt}=0$
\end_inset

 and the capacities are 
\begin_inset Formula $k_{si}=q_{i}-t_{i,min}$
\end_inset

,
\begin_inset Formula $k_{ij}=q_{i}-t_{i,min}$
\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout
There is no limitation in the number of taxis that can be sent on arc 
\begin_inset Formula $(i,j)$
\end_inset

, we choose the capacity as the maximum number of taxis that can be sent
 from node 
\begin_inset Formula $i$
\end_inset

 (we could also choose the capacity as the number of taxis that zone 
\begin_inset Formula $j$
\end_inset

 must recieve).
\end_layout

\end_inset

 and 
\begin_inset Formula $k_{jt}=t_{j,min}-q_{j}$
\end_inset

 finally we look for a flow of value sufficient to fulfill the demand constraint
, i.e.
 
\begin_inset Formula $\phi=\sum_{j\in Z_{-}}k_{jt}$
\end_inset

.
\end_layout

\begin_layout Standard
In addition to the classic formulation we may also impose a constraint to
 ensure that each zone has a number of taxis that is 
\begin_inset Formula $\leq t_{i,max}$
\end_inset

 but we have already observed this is less important with respect to the
 demand constraint, therefore we will not consider it.
 
\end_layout

\begin_layout Subsubsection
Minimum cost flow algorithm for problem 3.1.1
\end_layout

\begin_layout Standard
The algorithm we present, known
\emph on
 
\emph default
as
\emph on
 negative cycle elimination algorithm,
\emph default
 starts with a feasible flow 
\begin_inset Formula $\mathbf{x}$
\end_inset

 that can be found by means of a maximum flow algorithm like Edmonds-Karp
 (the complexity of the algorithm is 
\begin_inset Foot
status open

\begin_layout Plain Layout
Notice that in the network 
\begin_inset Formula $G'$
\end_inset

 the number of nodes is 
\begin_inset Formula $|Z|+2$
\end_inset

 and the number of arcs is 
\begin_inset Formula $|Z|+|Z_{+}||Z_{-}|$
\end_inset

.
\end_layout

\end_inset


\begin_inset Formula $O(|Z||A'|)=O(|Z|^{3})$
\end_inset

).
 Starting from graph 
\begin_inset Formula $G'$
\end_inset

 and an initial feasible flow 
\begin_inset Formula $\mathbf{x}$
\end_inset

 we can build the residual (or incremental network) 
\begin_inset Formula $\overline{G}=(Z\cup\{s,t\},\overline{A}$
\end_inset

) where we add an arc 
\begin_inset Formula $(i,j)\in\overline{A}$
\end_inset

 whenever there is:
\end_layout

\begin_layout Itemize
a non saturated arc 
\begin_inset Formula $(i,j)\in A'$
\end_inset

 with residual capacity 
\begin_inset Formula $\overline{k_{ij}}=k_{ij}-x_{ij}$
\end_inset

 and residual cost 
\begin_inset Formula $\overline{d_{ij}}=d_{ij}$
\end_inset

,
\end_layout

\begin_layout Itemize
a non empty arc 
\begin_inset Formula $(j,i)\in A'$
\end_inset

 with residual capacity 
\begin_inset Formula $\overline{k_{ij}}=x_{ij}$
\end_inset

and residual cost 
\begin_inset Formula $\overline{d_{ij}}=-d_{ij}$
\end_inset

.
\end_layout

\begin_layout Standard
A path from 
\begin_inset Formula $s$
\end_inset

 to 
\begin_inset Formula $t$
\end_inset

 in the residual network corresponds to a new feasible flow.
 Since we start with a maximum feasible flow (and by construction we cannot
 reduce it) the only way of modifying the solution without violating the
 flow conservation constraints is to vary the flow on a cycle (or on a set
 of cycles) by an identical quantity 
\begin_inset Formula $\delta$
\end_inset

.
 In fact, a flow variation on a route which does not close into itself would
 immediately bring to a violation of the flow conservation constraints which
 were satisfied by the original flow 
\begin_inset Formula $\mathbf{\mathrm{x}}$
\end_inset

.
 Considered a cycle 
\begin_inset Formula $C\in A'$
\end_inset

, the maximum practicable flow variation is given by:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\delta=\min_{(i,j)\in C}\{\overline{k_{ij}}\}
\]

\end_inset


\end_layout

\begin_layout Standard
The flow is updated according to the following rules:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
x_{ij}'=\begin{cases}
x_{ij}+\delta & if(i,j)\in A'\cap C\\
x_{ij}-\delta & if(j,i)\in A'\cap C\\
x_{ij} & otherwise
\end{cases}
\]

\end_inset


\end_layout

\begin_layout Standard
The variation of the total cost is given by
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\delta\sum_{(i,j)\in C}\overline{d_{ij}}
\]

\end_inset


\end_layout

\begin_layout Standard
This means that there is an improvement in the solution value only if cycle
 C has sum of negative residual costs.
 It can be proved that a flow 
\begin_inset Formula $\mathbf{\mathrm{x}}$
\end_inset

 is a minimum cost flow if and only if there exist no negative cycles in
 the residual graph.
 Here is the pseudocode.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithmic}[1]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
Function{selectTaxisToMove}{$G',K,D$}:$(X,cost)$ 
\backslash
Comment{Minimum cost flow}
\end_layout

\begin_layout Plain Layout

	
\backslash
item[]
\end_layout

\begin_layout Plain Layout

	
\backslash
State 
\backslash
Comment{Find an initial maximum feasible flow}
\end_layout

\begin_layout Plain Layout

	
\backslash
State $X 
\backslash
gets$ 
\backslash
Call{Edmonds-Karp}{$G',K$}
\end_layout

\begin_layout Plain Layout

	
\backslash
State $cost 
\backslash
gets 0$
\end_layout

\begin_layout Plain Layout

	
\backslash
ForAll{$(i,j) 
\backslash
in G'.A'$}
\end_layout

\begin_layout Plain Layout

		
\backslash
State $cost 
\backslash
gets cost + x_{ij}d_{ij}$
\end_layout

\begin_layout Plain Layout

	
\backslash
EndFor
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	
\backslash
item[]
\end_layout

\begin_layout Plain Layout

	
\backslash
State 
\backslash
Comment{Until there is a negative cost cycle...}
\end_layout

\begin_layout Plain Layout

	
\backslash
State $optimal 
\backslash
gets $
\backslash
textbf{false}
\end_layout

\begin_layout Plain Layout

	
\backslash
While{
\backslash
textbf{not }$optimal$}
\end_layout

\begin_layout Plain Layout

		
\backslash
State 
\backslash
Comment{...compute the residual network...}
\end_layout

\begin_layout Plain Layout

		
\backslash
State $(
\backslash
overline{G},
\backslash
overline{D},
\backslash
overline{K}) 
\backslash
gets $
\backslash
Call{residualNetwork}{$G,K,D,X$} 
\end_layout

\begin_layout Plain Layout

		
\backslash
State 
\backslash
Comment{...find a negatite cycle...}
\end_layout

\begin_layout Plain Layout

		
\backslash
State $C 
\backslash
gets $
\backslash
Call{findNegativeCycle}{$
\backslash
overline{G},
\backslash
overline{D},
\backslash
overline{K}$}
\end_layout

\begin_layout Plain Layout

		
\backslash
If{$C = 
\backslash
{
\backslash
}$}
\end_layout

\begin_layout Plain Layout

			
\backslash
State $optimal 
\backslash
gets $
\backslash
textbf{true}
\end_layout

\begin_layout Plain Layout

		
\backslash
Else
\end_layout

\begin_layout Plain Layout

			
\backslash
State 
\backslash
Comment{...update the flow}
\end_layout

\begin_layout Plain Layout

			
\backslash
State $
\backslash
delta 
\backslash
gets 
\backslash
min_{(i,j)
\backslash
in C}{
\backslash
overline{k_{ij}}}$
\end_layout

\begin_layout Plain Layout

			
\backslash
ForAll{$(i,j) 
\backslash
in G'.A'$}
\end_layout

\begin_layout Plain Layout

				
\backslash
If{$(i,j) 
\backslash
in C$}
\end_layout

\begin_layout Plain Layout

					
\backslash
State $x_{ij} 
\backslash
gets x_{ij} + 
\backslash
delta$
\end_layout

\begin_layout Plain Layout

					
\backslash
State $cost 
\backslash
gets cost + 
\backslash
delta 
\backslash
overline{d_{ij}}$
\end_layout

\begin_layout Plain Layout

				
\backslash
EndIf
\end_layout

\begin_layout Plain Layout

				
\backslash
If{$(j,i) 
\backslash
in C$}
\end_layout

\begin_layout Plain Layout

					
\backslash
State $x_{ij} 
\backslash
gets x_{ij} - 
\backslash
delta$
\end_layout

\begin_layout Plain Layout

					
\backslash
State $cost 
\backslash
gets cost + 
\backslash
delta 
\backslash
overline{d_{ij}}$
\end_layout

\begin_layout Plain Layout

				
\backslash
EndIf
\end_layout

\begin_layout Plain Layout

			
\backslash
EndFor
\end_layout

\begin_layout Plain Layout

		
\backslash
EndIf
\end_layout

\begin_layout Plain Layout

	
\backslash
EndWhile
\end_layout

\begin_layout Plain Layout

	
\backslash
State
\backslash
Return $(X,cost)$
\end_layout

\begin_layout Plain Layout


\backslash
EndFunction
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
selectTaxisToMove
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The algorithm is based on searching for negative cost cycles but no criterion
 has been specified to select one negative cost cycle when more than one
 are present, this has a negative impact on the complexity.
 Let's call 
\begin_inset Formula $k_{max}=\max_{(i,j)\in A'}\{k_{ij}\}$
\end_inset

 and 
\begin_inset Formula $d_{max}=\max_{(i,j)\in A'}\{d_{ij}\}$
\end_inset

, since the choice of the initial feasible solution is not in the least
 dictated by cost criteria, at the beginning in the worst case the cost
 (i.e.
 the total number of zones traveled by all taxis) of the provided solution
 is given at most by 
\begin_inset Formula $|A'|k_{max}d_{max}$
\end_inset

, we may suppose as well that the optimal solution in the extreme case has
 cost 
\begin_inset Formula $0$
\end_inset

.
 Observing that at each iteration of the algorithm the flow varies by at
 least one unit and that this induces a decrease in the value of the objective
 function by at least one unit, we will have to perform, in the worst case,
 
\begin_inset Formula $O(|A'|k_{max}d_{max})$
\end_inset

 iterations.
 Knowing that negative cycles can be recognized in 
\begin_inset Formula $O(|Z||A'|)$
\end_inset

, the algorithmâ€™s complexity is 
\begin_inset Formula $O(|Z||A'|^{2}k_{max}d_{max})$
\end_inset

, which is not polynomial
\begin_inset Foot
status open

\begin_layout Plain Layout
The number of bits needed to store 
\begin_inset Formula $k_{max}$
\end_inset

 (or 
\begin_inset Formula $d_{max}$
\end_inset

) is proportional to the 
\begin_inset Formula $\lg k_{max}$
\end_inset

, so the complexity is exponential with respect to the size of the instance.
\end_layout

\end_inset

.
 It can be demonstrated that, in case of a particular choice of the negative
 cycle, the algorithm is polynomial.
 For instance if we implement the function 
\begin_inset Formula $findNegativeCycle$
\end_inset

 with the 
\emph on
minimum mean-cost cycle canceling
\emph default
 algorithm we achieve a polynomial computational complexity of 
\begin_inset Formula $O(|Z|^{2}|A'|^{2}\lg(||Z|d_{max}))$
\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout
From R.
 K.
 Ahuja, T.
 L.
 Magnati, J.
 B.
 Orlin, Network Flows, 1993
\end_layout

\end_inset

.
\end_layout

\begin_layout Paragraph
Some observations
\end_layout

\begin_layout Itemize
The algorithm returns the 
\series bold
number
\series default
 of taxis to be moved from each zone to each zone, not 
\series bold
which
\series default
 taxis to move.
 We will assume to move the taxis that are located at the tail of the queue.
\end_layout

\begin_layout Itemize
We should require that the algorithm ensures a final value of 
\begin_inset Formula $q_{i}$
\end_inset

 strictly grater than 
\begin_inset Formula $t_{i,min}$
\end_inset

 to avoid too many invocations of the procedure (because if we ensure to
 have exactly 
\begin_inset Formula $t_{i,min}$
\end_inset

 taxis in each zone, right after one taxi goes into a non available state
 the procedure must be rexecuted), this can be done by considering a new
 value 
\begin_inset Formula $t_{i,min}^{'}=1.1t_{i,min}$
\end_inset

 that is used only define the number of taxis to be ensured in each zone
 and 
\series bold
not 
\series default
to decide when to execute the procedure.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithmic}[1]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
Function{relocateTaxis}{}
\end_layout

\begin_layout Plain Layout

	
\backslash
State $Z 
\backslash
gets TaxiQueueManager.getZones()$
\end_layout

\begin_layout Plain Layout

	
\backslash
State $numberOfAvailableTaxis 
\backslash
gets TaxiQueueManager.getNumberOfAvailableTaxis()$
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	
\backslash
item[]
\end_layout

\begin_layout Plain Layout

	
\backslash
State 
\backslash
Comment{Compute the closure of the graph}
\end_layout

\begin_layout Plain Layout

	
\backslash
State $(G^+,D) 
\backslash
gets $
\backslash
Call{graphTransitiveClosure}{Z}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	
\backslash
item[]
\end_layout

\begin_layout Plain Layout

	
\backslash
State 
\backslash
Comment{Build the network G'}
\end_layout

\begin_layout Plain Layout

	
\backslash
State $G' 
\backslash
gets (Z
\backslash
bigcup
\backslash
{s,t
\backslash
},
\backslash
{
\backslash
})$
\end_layout

\begin_layout Plain Layout

	
\backslash
ForAll{$(i,j)
\backslash
in G^+.A^+$}
\end_layout

\begin_layout Plain Layout

		
\backslash
If{
\backslash
textbf{not }$i.isLackingOfTaxis(numberOfAvailableTaxis)$
\backslash
textbf{ and }$j.isLackingOfTaxis(numberOfAvailableTaxis)$}
\end_layout

\begin_layout Plain Layout

			
\backslash
State $G'.A' 
\backslash
gets G'.A' + 
\backslash
{(i,j)
\backslash
}$
\end_layout

\begin_layout Plain Layout

			
\backslash
State $k_{ij} 
\backslash
gets TaxiQueueManager.getNumberOfTaxis(i) - t_{i,min}$
\end_layout

\begin_layout Plain Layout

		
\backslash
EndIf
\end_layout

\begin_layout Plain Layout

	
\backslash
EndFor
\end_layout

\begin_layout Plain Layout

	
\backslash
item[]
\end_layout

\begin_layout Plain Layout

	
\backslash
ForAll{$i
\backslash
in G'.N - 
\backslash
{s,t
\backslash
}$}
\end_layout

\begin_layout Plain Layout

		
\backslash
If{
\backslash
textbf{not }$i.isLackingOfTaxis(numberOfAvailableTaxis)$}
\end_layout

\begin_layout Plain Layout

			
\backslash
State $G'.A' 
\backslash
gets G'.A + 
\backslash
{(s,i)
\backslash
}$
\end_layout

\begin_layout Plain Layout

			
\backslash
State $k_{si} 
\backslash
gets TaxiQueueManager.getNumberOfTaxis(i) - t_{i,min}$
\end_layout

\begin_layout Plain Layout

			
\backslash
State $d_{si} 
\backslash
gets 0$
\end_layout

\begin_layout Plain Layout

		
\backslash
Else
\end_layout

\begin_layout Plain Layout

			
\backslash
State $G'.A' 
\backslash
gets G'.A + 
\backslash
{(i,t)
\backslash
}$
\end_layout

\begin_layout Plain Layout

			
\backslash
State $k_{it} 
\backslash
gets t_{i,min} - TaxiQueueManager.getNumberOfTaxis(i)$
\end_layout

\begin_layout Plain Layout

			
\backslash
State $d_{it} 
\backslash
gets 0$
\end_layout

\begin_layout Plain Layout

		
\backslash
EndIf
\end_layout

\begin_layout Plain Layout

	
\backslash
EndFor
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	
\backslash
item[]
\end_layout

\begin_layout Plain Layout

	
\backslash
State $X 
\backslash
gets $
\backslash
Call{selectTaxisToMove}{$G',K,D$}
\end_layout

\begin_layout Plain Layout

	
\backslash
State 
\backslash
Comment{Send notification to taxis}
\end_layout

\begin_layout Plain Layout

	
\backslash
ForAll{$x_{ij} > 0$}
\end_layout

\begin_layout Plain Layout

		
\backslash
ForAll{$1<=n<=x_{ij}$}
\end_layout

\begin_layout Plain Layout

				
\backslash
State $taxi 
\backslash
gets TaxiQueueManager.getLast(i)$
\end_layout

\begin_layout Plain Layout

				
\backslash
State 
\backslash
Call{TMASendNotification}{$taxi,j$}
\end_layout

\begin_layout Plain Layout

		
\backslash
EndFor
\end_layout

\begin_layout Plain Layout

	
\backslash
EndFor
\end_layout

\begin_layout Plain Layout


\backslash
EndFunction
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
relocateTaxis
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage clearpage
\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{tikzpicture}[->,>=stealth',main_node/.style={circle,fill=blue!20,draw,minim
um size=1em,inner sep=3pt]},every edge/.append style={font=
\backslash
scriptsize}]   
\end_layout

\begin_layout Plain Layout


\backslash
node[main_node] (1) {$a$};     
\end_layout

\begin_layout Plain Layout


\backslash
node[main_node] (2) [below = 1.5cm of 1]  {$b$};     
\end_layout

\begin_layout Plain Layout


\backslash
node[main_node] (3) [below = 1.5cm of 2] {$c$};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
node[main_node] (4) [below right = 0.5cm and 3cm of 1] {$d$};     
\end_layout

\begin_layout Plain Layout


\backslash
node[main_node] (5) [below right = 2.5cm and 3cm of 1]  {$e$};   
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
node[main_node] (6) [left = 2cm of 2] {$s$};     
\end_layout

\begin_layout Plain Layout


\backslash
node[main_node] (7) [right = 5cm of 2]  {$t$};     
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout


\backslash
path[draw,thick]
\end_layout

\begin_layout Plain Layout

(6) edge node [above] {$6/0$} (1)
\end_layout

\begin_layout Plain Layout

(6) edge node [above] {$2/0$} (2)
\end_layout

\begin_layout Plain Layout

(6) edge node [above] {$3/0$} (3)  
\end_layout

\begin_layout Plain Layout

(4) edge node [above] {$1/0$} (7)
\end_layout

\begin_layout Plain Layout

(5) edge node [above] {$2/0$} (7)  
\end_layout

\begin_layout Plain Layout

(1) edge node [above] {$6/4$} (4)
\end_layout

\begin_layout Plain Layout

(1) edge node [above] {$6/3$} (5)     
\end_layout

\begin_layout Plain Layout

(2) edge node [above, near end] {$2/2$} (4)     
\end_layout

\begin_layout Plain Layout

(2) edge node [above] {$2/3$} (5)     
\end_layout

\begin_layout Plain Layout

(3) edge node [above, near end] {$3/1$} (4)     
\end_layout

\begin_layout Plain Layout

(3) edge node [above] {$3/2$} (5);        
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align center
(a)
\end_layout

\begin_layout Standard
\align center
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{tikzpicture}[->,>=stealth',main_node/.style={circle,fill=blue!20,draw,minim
um size=1em,inner sep=3pt]},every edge/.append style={font=
\backslash
scriptsize}]   
\end_layout

\begin_layout Plain Layout


\backslash
node[main_node] (1) {$a$};     
\end_layout

\begin_layout Plain Layout


\backslash
node[main_node] (2) [below = 1.5cm of 1]  {$b$};     
\end_layout

\begin_layout Plain Layout


\backslash
node[main_node] (3) [below = 1.5cm of 2] {$c$};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
node[main_node] (4) [below right = 0.5cm and 3cm of 1] {$d$};     
\end_layout

\begin_layout Plain Layout


\backslash
node[main_node] (5) [below right = 2.5cm and 3cm of 1]  {$e$};   
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
node[main_node] (6) [left = 2cm of 2] {$s$};     
\end_layout

\begin_layout Plain Layout


\backslash
node[main_node] (7) [right = 5cm of 2]  {$t$};     
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout


\backslash
path[draw,thick]
\end_layout

\begin_layout Plain Layout

(6) edge node [above] {$3/0$} (1)
\end_layout

\begin_layout Plain Layout

(6) edge node [above] {$0/0$} (2)
\end_layout

\begin_layout Plain Layout

(6) edge node [above] {$0/0$} (3)  
\end_layout

\begin_layout Plain Layout

(4) edge node [above] {$1/0$} (7)
\end_layout

\begin_layout Plain Layout

(5) edge node [above] {$2/0$} (7)  
\end_layout

\begin_layout Plain Layout

(1) edge node [above] {$1/4$} (4)
\end_layout

\begin_layout Plain Layout

(1) edge node [above] {$2/3$} (5)     
\end_layout

\begin_layout Plain Layout

(2) edge node [above, near end] {$0/2$} (4)     
\end_layout

\begin_layout Plain Layout

(2) edge node [above] {$0/3$} (5)     
\end_layout

\begin_layout Plain Layout

(3) edge node [above, near end] {$0/1$} (4)     
\end_layout

\begin_layout Plain Layout

(3) edge node [above] {$0/2$} (5);        
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align center
(b)
\end_layout

\begin_layout Standard
\align center
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{tikzpicture}[->,>=stealth',main_node/.style={circle,fill=blue!20,draw,minim
um size=1em,inner sep=3pt]},every edge/.append style={font=
\backslash
scriptsize}]   
\end_layout

\begin_layout Plain Layout


\backslash
tikzstyle{LabelStyle}=[fill=white,sloped]
\end_layout

\begin_layout Plain Layout


\backslash
node[main_node] (1) {$a$};     
\end_layout

\begin_layout Plain Layout


\backslash
node[main_node] (2) [below = 1.5cm of 1]  {$b$};     
\end_layout

\begin_layout Plain Layout


\backslash
node[main_node] (3) [below = 1.5cm of 2] {$c$};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
node[main_node] (4) [below right = 0.5cm and 3cm of 1] {$d$};     
\end_layout

\begin_layout Plain Layout


\backslash
node[main_node] (5) [below right = 2.5cm and 3cm of 1]  {$e$};   
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
node[main_node] (6) [left = 2cm of 2] {$s$};     
\end_layout

\begin_layout Plain Layout


\backslash
node[main_node] (7) [right = 5cm of 2]  {$t$};     
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout


\backslash
path[draw,thick]
\end_layout

\begin_layout Plain Layout

(6) edge [bend left=15, draw=blue] node [above] {$3/0$} (1)
\end_layout

\begin_layout Plain Layout

(1) edge [bend left=15, draw=green] node [above] {$3/0$} (6)
\end_layout

\begin_layout Plain Layout

(6) edge [draw=blue] node [above] {$2/0$} (2)
\end_layout

\begin_layout Plain Layout

(6) edge [draw=blue] node [above] {$3/0$} (3)  
\end_layout

\begin_layout Plain Layout

%(4) edge [draw=blue] node [above] {$1/0$} (7)
\end_layout

\begin_layout Plain Layout

%(5) edge [draw=blue] node [below] {$2/0$} (7) 
\end_layout

\begin_layout Plain Layout

(7) edge [draw=green] node [below] {$1/0$} (4)
\end_layout

\begin_layout Plain Layout

(7) edge [draw=green] node [below] {$2/0$} (5)
\end_layout

\begin_layout Plain Layout

(1) edge [bend left=15, draw=blue] node [above] {$5/4$} (4)
\end_layout

\begin_layout Plain Layout

(1) edge [bend left=15, draw=blue] node [above, very near end] {$4/3$} (5)
 
\end_layout

\begin_layout Plain Layout

(4) edge [bend left=15, draw=green] node [above] {$1/-4$} (1)
\end_layout

\begin_layout Plain Layout

(5) edge [bend left=15, draw=green] node [below, very near end] {$2/-3$}
 (1)      
\end_layout

\begin_layout Plain Layout

(2) edge [draw=blue] node [above, very near start] {$2/2$} (4)     
\end_layout

\begin_layout Plain Layout

(2) edge [draw=blue] node [above, near start] {$2/3$} (5)     
\end_layout

\begin_layout Plain Layout

(3) edge [draw=blue] node [above, near start] {$3/1$} (4)     
\end_layout

\begin_layout Plain Layout

(3) edge [draw=blue] node [above] {$3/2$} (5);
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align center
(c)
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{tikzpicture}[->,>=stealth',main_node/.style={circle,fill=blue!20,draw,minim
um size=1em,inner sep=3pt]},every edge/.append style={font=
\backslash
scriptsize}]   
\end_layout

\begin_layout Plain Layout


\backslash
node[main_node] (1) {$a$};     
\end_layout

\begin_layout Plain Layout


\backslash
node[main_node] (2) [below = 1.5cm of 1]  {$b$};     
\end_layout

\begin_layout Plain Layout


\backslash
node[main_node] (3) [below = 1.5cm of 2] {$c$};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
node[main_node] (4) [below right = 0.5cm and 3cm of 1] {$d$};     
\end_layout

\begin_layout Plain Layout


\backslash
node[main_node] (5) [below right = 2.5cm and 3cm of 1]  {$e$};   
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
node[main_node] (6) [left = 2cm of 2] {$s$};     
\end_layout

\begin_layout Plain Layout


\backslash
node[main_node] (7) [right = 5cm of 2]  {$t$};     
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
path[draw,thick]
\end_layout

\begin_layout Plain Layout

(6) edge [bend left=15, draw=blue] node [above] {$3/0$} (1)
\end_layout

\begin_layout Plain Layout

(1) edge [ultra thick, bend left=15, draw=red] node [above] {$3/0$} (6)
\end_layout

\begin_layout Plain Layout

(6) edge [ultra thick, draw=red] node [above] {$2/0$} (2)
\end_layout

\begin_layout Plain Layout

(6) edge [draw=blue] node [above] {$3/0$} (3)  
\end_layout

\begin_layout Plain Layout

%(4) edge [draw=blue] node [above] {$1/0$} (7)
\end_layout

\begin_layout Plain Layout

%(5) edge [draw=blue] node [below] {$2/0$} (7) 
\end_layout

\begin_layout Plain Layout

(7) edge [draw=green] node [below] {$1/0$} (4)
\end_layout

\begin_layout Plain Layout

(7) edge [draw=green] node [below] {$2/0$} (5)
\end_layout

\begin_layout Plain Layout

(1) edge [bend left=15, draw=blue] node [above] {$5/4$} (4)
\end_layout

\begin_layout Plain Layout

(1) edge [bend left=15, draw=blue] node [above, very near end] {$4/3$} (5)
 
\end_layout

\begin_layout Plain Layout

(4) edge [ultra thick, bend left=15, draw=red] node [above] {$1/-4$} (1)
\end_layout

\begin_layout Plain Layout

(5) edge [bend left=15, draw=green] node [below, very near end] {$2/-3$}
 (1)      
\end_layout

\begin_layout Plain Layout

(2) edge [ultra thick, draw=red] node [above, very near start] {$2/2$} (4)
     
\end_layout

\begin_layout Plain Layout

(2) edge [draw=blue] node [above, near start] {$2/3$} (5)     
\end_layout

\begin_layout Plain Layout

(3) edge [draw=blue] node [above, near start] {$3/1$} (4)     
\end_layout

\begin_layout Plain Layout

(3) edge [draw=blue] node [above] {$3/2$} (5);
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

        
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
(d)
\end_layout

\begin_layout Plain Layout
\align center
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{tikzpicture}[->,>=stealth',main_node/.style={circle,fill=blue!20,draw,minim
um size=1em,inner sep=3pt]},every edge/.append style={font=
\backslash
scriptsize}]   
\end_layout

\begin_layout Plain Layout


\backslash
node[main_node] (1) {$a$};     
\end_layout

\begin_layout Plain Layout


\backslash
node[main_node] (2) [below = 1.5cm of 1]  {$b$};     
\end_layout

\begin_layout Plain Layout


\backslash
node[main_node] (3) [below = 1.5cm of 2] {$c$};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
node[main_node] (4) [below right = 0.5cm and 3cm of 1] {$d$};     
\end_layout

\begin_layout Plain Layout


\backslash
node[main_node] (5) [below right = 2.5cm and 3cm of 1]  {$e$};   
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
node[main_node] (6) [left = 2cm of 2] {$s$};     
\end_layout

\begin_layout Plain Layout


\backslash
node[main_node] (7) [right = 5cm of 2]  {$t$};     
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout


\backslash
path[draw,thick]
\end_layout

\begin_layout Plain Layout

(6) edge node [above] {$2/0$} (1)
\end_layout

\begin_layout Plain Layout

(6) edge node [above] {$1/0$} (2)
\end_layout

\begin_layout Plain Layout

(6) edge node [above] {$0/0$} (3)  
\end_layout

\begin_layout Plain Layout

(4) edge node [above] {$1/0$} (7)
\end_layout

\begin_layout Plain Layout

(5) edge node [above] {$2/0$} (7)  
\end_layout

\begin_layout Plain Layout

(1) edge node [above] {$0/4$} (4)
\end_layout

\begin_layout Plain Layout

(1) edge node [above left] {$2/3$} (5)     
\end_layout

\begin_layout Plain Layout

(2) edge node [above, near end] {$1/2$} (4)     
\end_layout

\begin_layout Plain Layout

(2) edge node [above] {$0/3$} (5)     
\end_layout

\begin_layout Plain Layout

(3) edge node [above, near end] {$0/1$} (4)     
\end_layout

\begin_layout Plain Layout

(3) edge node [above] {$0/2$} (5);        
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
(e)
\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
An iteration of the minumum cost flow algorithm.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
(a) The initial network, arcs are labeled with 
\begin_inset Formula $k_{ij}/d_{ij}$
\end_inset

.
 (b) A maximum feasible flow of cost 
\begin_inset Formula $10$
\end_inset

 found with Edmonds-Karp, arcs are labeled with 
\begin_inset Formula $x_{ij}/d_{ij}$
\end_inset

.
 (c) The incremetal network associated to the flow at point b, arcs are
 labeled 
\begin_inset Formula $\overline{k_{ij}}/\overline{d_{ij}}$
\end_inset

.
 (d) A negative cost cycle is found: s - b - d - a - s, 
\begin_inset Formula $\delta=\min\{2,4,1,3\}=1$
\end_inset

.
 (e) The new feasible flow obtained applying the negative cost cycle algorithm
 of cost 
\begin_inset Formula $8$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage clearpage
\end_inset


\end_layout

\begin_layout Subsection
Taxi selector
\end_layout

\begin_layout Standard
Taxi selector is the component in charge of searching for a taxi whenever
 a request comes.
 The function
\emph on
 findTaxi
\emph default
 looks for the first taxi available according to the policies defined in
 the RASD document, sends the request to the taxi driver and, in case no
 taxi are available at all, to puts the request on hold.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithmic}[1]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
Function{findTaxi}{$request$}
\end_layout

\begin_layout Plain Layout

	
\backslash
State $visitedZones 
\backslash
gets $
\backslash
textbf{[false]}
\end_layout

\begin_layout Plain Layout

	
\backslash
State $zone
\backslash
gets request.getLocation().getZone()$
\end_layout

\begin_layout Plain Layout

	
\backslash
If {$TaxiQueueManager.getNumberOfTaxis(zone) = 0$}
\end_layout

\begin_layout Plain Layout

		
\backslash
State $visitedZones[zone] 
\backslash
gets$(
\backslash
textbf{true})
\end_layout

\begin_layout Plain Layout

		
\backslash
State $adjZones
\backslash
gets zone.getAdjacentZones()$
\end_layout

\begin_layout Plain Layout

		
\backslash
State $found
\backslash
gets$ 
\backslash
textbf{false}
\end_layout

\begin_layout Plain Layout

		
\backslash
item[]
\end_layout

\begin_layout Plain Layout

		
\backslash
While{
\backslash
textbf{not }$found$
\backslash
textbf{ and not }$adjZones.isEmpty()$}
\end_layout

\begin_layout Plain Layout

				
\backslash
State $z
\backslash
gets adjZones.pop()$
\end_layout

\begin_layout Plain Layout

				
\backslash
State $visitedZones[zone] 
\backslash
gets$(
\backslash
textbf{true})
\end_layout

\begin_layout Plain Layout


\backslash
item[]
\end_layout

\begin_layout Plain Layout

				
\backslash
If {$TaxiQueueManager.getNumberOfTaxis(z) = 0$}
\end_layout

\begin_layout Plain Layout

					
\backslash
ForAll{$h 
\backslash
in z.getAdjacentZones()$ s.t.
 
\backslash
textbf{not} $visitedZones[h]$}
\end_layout

\begin_layout Plain Layout

						
\backslash
State $adjZones.add(h)$
\end_layout

\begin_layout Plain Layout

					
\backslash
EndFor
\end_layout

\begin_layout Plain Layout

				
\backslash
Else
\end_layout

\begin_layout Plain Layout

					
\backslash
State $zone 
\backslash
gets z$
\end_layout

\begin_layout Plain Layout

					
\backslash
State $found 
\backslash
gets $
\backslash
textbf{true}
\end_layout

\begin_layout Plain Layout

				
\backslash
EndIf
\end_layout

\begin_layout Plain Layout


\backslash
item[]
\end_layout

\begin_layout Plain Layout

		
\backslash
EndWhile
\end_layout

\begin_layout Plain Layout

	
\backslash
item[]
\end_layout

\begin_layout Plain Layout

	
\backslash
EndIf
\end_layout

\begin_layout Plain Layout

	
\backslash
item[]
\end_layout

\begin_layout Plain Layout

	
\backslash
If{not $found$}
\end_layout

\begin_layout Plain Layout

		
\backslash
State 
\backslash
Call{putOnHold}{$request$}
\end_layout

\begin_layout Plain Layout

	
\backslash
Else
\end_layout

\begin_layout Plain Layout

		
\backslash
State $taxi 
\backslash
gets TaxiQueueManager.getFirst(zone)$
\end_layout

\begin_layout Plain Layout

		
\backslash
State 
\backslash
Call{TMASendRequest}{$taxi,request$}
\end_layout

\begin_layout Plain Layout

		
\backslash
State 
\backslash
Call{waitForAnswer}{1 minute}
\end_layout

\begin_layout Plain Layout

	
\backslash
EndIf
\end_layout

\begin_layout Plain Layout


\backslash
EndFunction
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
findTaxi
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_body
\end_document
